#include "common.hpp"
#include "flags.h"

#include <rdge/util/io/rwops_base.hpp>

#include <stdio.h>
#include <stdlib.h>
#include <ctime>
#include <iostream>
#include <fstream>
#include <stdexcept>

// Asset packer
//
// Command line utility that builds a packed asset file and corresponding
// header file (.hpp) that contains an enum that maps to each imported asset.
//
// To run the packer expects a parent directory that contains sub-directories
// containing all the different asset types.
//
// parent_directory/
//     images/
//     fonts/
//     spritesheets/
//     tilemaps/
//     tilesets/
//
// The packer will iterate through each child directory and import every
// valid file.

using json = nlohmann::json;
using namespace rdge;

namespace {

void
PrintUsage (void)
{
    std::cout << "\nPacks exported files and generates a asset table header\n\n"
              << "Input/output directories are specified in a json config\n"
              << "file.  This is intended to be ran after the export scripts\n"
              << "have completed.\n\n"
              << "Usage:\n"
              << "asset_pack /path/to/config/ [flags]\n\n"
              << "Flags:\n"
              << "  --silent    Opress confirmation\n\n";
}

std::string
PrintImportResult (const import_result& result)
{
    std::ostringstream ss;
    ss << "  success: " << std::right << std::setw(3) << result.success
       << "  failed:  " << std::right << std::setw(3) << result.failed
       << "  skipped: " << std::right << std::setw(3) << result.skipped
       << std::endl;

    return ss.str();
}

struct generated_header_file
{
    std::ofstream ofs;
    nlohmann::json asset_table; // Table of all assets
    nlohmann::json asset_enums; // Asset specific enums added from importing

    generated_header_file (const std::string file)
        : ofs(file, std::ofstream::out | std::ofstream::trunc)
        , asset_enums(json::array())
    {
        asset_table = { { "name", "rdge_asset_pack_table" },
                        { "values", json::array() } };
    }

    ~generated_header_file (void) noexcept
    {
        ofs.close();
    }

    void add_asset (const imported_asset& asset)
    {
        std::ostringstream ss;
        ss << "rdge_asset_" << asset.info.type << "_" << asset.name;
        this->asset_table["values"].push_back({{ "n", ss.str() }, { "v", asset.table_id }});

        for (const auto& e : asset.enums)
        {
            this->asset_enums.push_back(e);
        }
    }

    void write_enum (const nlohmann::json& element)
    {
        ofs << "enum " << element["name"].get<std::string>() << "\n"
            << "{\n";

        for (auto& value : element["values"])
        {
            ofs << "    " << value["n"].get<std::string>()
                << " = " << value["v"].get<int32>() << ",\n";
        }

        ofs << "};\n\n";
    }

    void write (void)
    {
        std::time_t now = std::time(NULL);
        std::tm* t = std::localtime(&now);
        char buffer[50] = {};
        std::strftime(buffer, 50, "%c", t);

        ofs << "/************************************************************/\n"
            << "/**              File generated by asset_packer            **/\n"
            << "/************************************************************/\n"
            << "\n"
            << "// Created: " << buffer << "\n"
            << "// Version: " << RDGE_ASSET_PACK_VERSION << "\n"
            << "\n"
            << "#pragma once\n"
            << "\n";

        write_enum(this->asset_table);
        for (const auto& e : this->asset_enums)
        {
            write_enum(e);
        }

        ofs.flush();
    }
};

} // anonymous namespace

int
main (int argc, char** argv)
{
    const flags::args args(argc, argv);
    if (args.get<bool>("h", false) || args.get<bool>("help", false))
    {
        PrintUsage();
        return EXIT_SUCCESS;
    }

    const auto silent = args.get<bool>("silent", false);

    const auto& pargs = args.positional();
    if (pargs.empty())
    {
        std::cout << "Invalid request:\n";
        PrintUsage();
        return EXIT_FAILURE;
    }

    global_import_state global_state;

    try {
        std::string config_file(pargs[0]);
        auto rwops = rwops_base::from_file(config_file.c_str(), "rt");
        auto sz = rwops.size();

        std::string file_data(sz + 1, '\0');
        rwops.read((void*)file_data.data(), sizeof(char), sz);

        const auto j = json::parse(file_data);
        if ((j.count("cooker") == 0) || (j.count("packer") == 0))
        {
            throw std::invalid_argument("Invalid config format");
        }

        const auto& j_cooker = j["cooker"];
        const auto& j_packer = j["packer"];
        if ((j_cooker.count("export_path") == 0) ||
            (j_packer.count("data_file") == 0) ||
            (j_packer.count("header_file") == 0))
        {
            throw std::invalid_argument("Invalid config format");
        }

        global_state.parent_dir = j_cooker["export_path"].get<std::string>();
        global_state.data_file = j_packer["data_file"].get<std::string>();
        global_state.header_file = j_packer["header_file"].get<std::string>();
    } catch (const std::exception& ex) {
        std::cout << "Exception reading config file: " << ex.what() << '\n';
        return EXIT_FAILURE;
    }

    // !! IMPORTANT !!
    // Order of import is critical.  Certain asset types have other type dependencies.
    // Images                  <--   Spritesheet & Tileset
    // Tileset & Spritesheet   <--   Tilemap

    import_result totals;

    auto image_result = ImportImages(global_state);
    totals += image_result;

    auto font_result = ImportFonts(global_state);
    totals += font_result;

    auto spritesheet_result = ImportSpritesheets(global_state);
    totals += spritesheet_result;

    auto tileset_result = ImportTilesets(global_state);
    totals += tileset_result;

    auto tilemap_result = ImportTilemaps(global_state);
    totals += tilemap_result;

    std::cout << "\nImport Summary\n\n";
    std::cout << "Image:       " << PrintImportResult(image_result);
    std::cout << "Font:        " << PrintImportResult(font_result);
    std::cout << "Spritesheet: " << PrintImportResult(spritesheet_result);
    std::cout << "Tilesets:    " << PrintImportResult(tileset_result);
    std::cout << "Tilemaps:    " << PrintImportResult(tilemap_result);
    std::cout << "-------------------------------------------------------\n"
              << "Total:       " << PrintImportResult(totals);

    if (!silent)
    {
        std::cout << "\nContinue and write files? (y/n)\n";
        char cont;
        while (std::cin >> cont)
        {
            if (cont == 'y')
            {
                break;
            }
            else if (cont == 'n')
            {
                std::cout << "\nAborted\n";
                return EXIT_SUCCESS;
            }
        }
    }

    FILE* pack_file = fopen(global_state.data_file.c_str(), "wb");
    generated_header_file gen_header(global_state.header_file);
    if (pack_file && gen_header.ofs.is_open())
    {
        using namespace rdge::asset_pack;

        header h = {};
        h.magic_value = RDGE_MAGIC_VALUE;
        h.version = RDGE_ASSET_PACK_VERSION;
        h.asset_count = global_state.running_count;
        h.assets = sizeof(header);
        fwrite(&h, sizeof(header), 1, pack_file);

        uint32 asset_table_size = h.asset_count * sizeof(asset_info);
        for (auto& import : global_state.imported_assets)
        {
            gen_header.add_asset(import);

            import.info.offset += sizeof(header) + asset_table_size;
            fwrite(&import.info, sizeof(asset_info), 1, pack_file);
        }

        for (const auto& import : global_state.imported_assets)
        {
            fwrite(import.data, import.info.size, 1, pack_file);
            free(import.data);
        }

        gen_header.write();
        fclose(pack_file);
    }
    else
    {
        std::cout << "ERROR: Couldn't open file\n";
        return EXIT_FAILURE;
    }

    std::cout << "\nFinished\n";
    return EXIT_SUCCESS;
}
